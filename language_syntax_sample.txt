fn main() {
    // entry point
}

fn fn_name (<b/w/h> p1, <b/w/h> p2, ...) -> [b/w/h], [b/w/h], ... {
    [return [...];]
}

fn_name(...);

syscall(<id>, [p1], ...);

read_keyboard() -> w; // -1 if not pressed, -2 if addr not set, otherwise ascii key id

set_screen_dims(w width, w height); // Set 2D pixel dimensions of screen

set_keyboard_addr(w addr); // Set address of where to read keyboard from

set_screen_addr(w addr); // Set address of first screen pixel (topleft)

write_pixel(b red, b green, b blue, w x, w y) -> w; // -1 if addr not set, -2 if dims not set, 0 if success

to_w() // Sign extend the value

to_b() // Take least significant byte

to_h() // Sign extend or take least significant two bytes

// Operators
>
>=
<=
<
==
!=
+
-
/
*
<<  // sll 
>>  // srl
>>> // sra
=
+=
-=
*=
/=
++
--
&
|
!

<b/w/h> var_name = <0x.../0b.../...>;
<b/w/h>[<length>] arr_name = <0x.../0b.../...>; // One value means array will be populated with length repeats of that item
<b/w/h>[<length>] arr_name = <0x.../0b.../...>, ...; // Otherwise must list all items in array explicitly

if ( <expression> ) {

} elif ( <expression> ) {

} else {

}

while ( <expression> ) {

}

// Literals like 0, 0x44, 0b101, are typed based on context.
// If passed as a parameter, they are typed to the parameter. 
// If assigned to a variable, they are typed based on the variable.
// If in an expression with at least one variable, typed to match that variable. 
// If an expression has two variables which don't match, an error occurs
// If in an expression with no variables, all are typed as the longest of all the literals in the expression
// If no context is available, type based on length (If fits into byte, type as byte. Otherwise check half word, then word)
